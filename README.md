# 페이지 제작하기

# HTML
    파비콘 : 홈페이지 타이틀 옆에 붙는 조그만한 아이콘이다. 실제 작업시 16X16 픽셀로 작업한다.
    <link rel="shortcut icon" href="파비콘 파일 경로"> 

# Emmet 문법
    에밋은 html, xml 문서 등을 편집할 때 빠른 코딩을 위해 사용하는 플러그인이다. 간단한 몇 가지 코드만 입력하면, 자동으로 완전한 코드를 생성해 준다.
        
        1. 자식(하위)요소 >
        div>ul>li

        <div>
            <ul>
                <li></li>
            </ul>
        </div>

        2. 형제 요소
        div>p+span

        <div>
            <p></p>
            <span></span>
        </div>

        3. 올라가기 ^

        div>ul>li^p+a

        <div>
            <ul>
                <li></li>
            </ul>
            <p></p>
            <a href=''></a>
        </div>

        4. 반복하기 *

        div>ul>li*3

        <div>
            <ul>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>

        5. 그룹화 ()

        div>(header>ul>li*2)+footer

        <div>
            <header>
                <ul>
                    <li></li>
                    <li></li>
                </ul>
            </header>
            <footer></footer>
        </div>

        6. 클래스 .class -> div.comtainer 
        7. 아이디 #id -> span#hello
        8. 속성 [attr] -> td[title="bye" colspan=5]
        9. 넘버링 $ -> ul>li.item$*5 : 숫자대로 나열.
            &@5 -> 뒤의 숫자부터 시작(0부터 매김)
        10. 텍스트 .fruit{banana} -> <div class='fruit'>banana</div> 


# CSS
    keyframes : jquery를 사용하지 않고 css만으로 동적인 효과를 낼 수 있다.
    position : 문서 상에 요소를 배치하는 방법이다.
        relative - 요소 자기 자신을 기준으로 배치
        absolute - 가장 가까운 위치에 있는 부모(조상)요소를 기준으로 배치, 조상 중 포지션을 가진 요소가 없다면 초기 컨테이너 블록<body>을 기준으로 삼는다.
        fixed - 뷰포트 기준으로 배치
        stickey - 스크롤 영역 기준으로 배치
    word-break : 줄바꿈할 때 어떤 기준으로 줄바꿈할지 정하는 속성이다.
# reset.css
    웹 브라우저마다 각기 다른 기본값이 지정되어 있어, 이를 초기화함으로써 다양한 웹브라우저에서도 동일한 스타일이 적용되도록 하는 설정이다.

# javascript
    document : 웹 페이지에 존재하는 html 요소에 접근하고자 할 때는 반드시 document 객체를 사용해야 한다.
    alert : 알람 메시지를 띄울 때 사용한다.
    focus() : 해당 요소에 포커스를 부여하여,
        1. 텍스트 창의 경우, 커서를 위치시켜 바로 입력이 가능하다.
        2. 버튼의 경우, 엔터 키를 눌렀을 때 클릭 효과를 나타낸다.

# js 스크립트 경로
    내부스크립트 :
        <script>
            console.log('hello')
        </script>
    외부스크립트 :
        <script src='파일경로'></script>

# js 출력 방법
    1. 문서 내에 요소를 선택하여 출력하는 방법(innerHTML,innerText 등)
    2. 문서 내에 직접 출력하는 방법(write 등)
        -기존에 html요소를 다 지우고 작성하기 때문에 권장하지 않음.
    3. 사용자 인터럭션(alert, confilm 등)
    4. 콘솔 (console.log, console.table 등)

# js 코드 구조
    - 문(statement)은 세미콜론으로 구분
    - 문은 값, 연산자, 키워드, 명령어, 표현식(값으로 평가, 함수나 key, index를 통한 값의 호출도 표현식) 등으로 구성된다.
    - 공백 병합(shift+enter)
    - 주석 : /* 한 줄 주석입니다. */
    - 엄격 모드(strict mode)
        1."use scrict" (class의 경우 엄격모드가 기본)
        2.js 언어의 문법을 좀 더 엄격히 적용하여 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시키는 것이다.
        3. 함수별로 엄격모드를 다르게 적용할 수 있으나 혼란을 야기할 수 있다.


# 변수
    변수는 숫자로 시작할 수 없다.
    띄어쓰기가 안된다.
    예약어를 사용할 수 없다.
    &를 제외한 특수문자를 사용하지 않는다.
    class는 첫 문자를 대문자로, 나머지는 보통 소문자로 시작한다.

    # 선언방식
    1. var : 함수 레벨 스코프, 재선언 시 에러가 나오지 않고 각기 다른 값이 출력된다. 간단한 테스트에는 편리 할 수 있겠으나, 코드량이 많아 진다면 파악하기 힘들뿐더러 값이 바뀔 우려가 있다.

    2. let : 블록 레벨 스코프, 재선언시 에러 메시지가 나온다. 콘솔에서는 에러 X, 변경가능한 자료형

    3. const : 블록 레벨 스코프, 재선언시 에러 O, 콘솔에서는 에러 X, 변경 불가능한 자료형

# 변수의 형
    원시타입(primitive types) : number, string, boolean, null, undefined, symbol(ES6 추가, 변경 불가능한 유일한 값)

    참조타입(reference types) : object(object, array, map, set), function

    숫자(Number)
        

# 연산
    1. 산술 연산자(+, - , /, *, **, %)
    2. 할당 연산자(=, +=, -=, /=, *=, **=, %=) : 어떤값을 누적해줄 때 사용
    3. 논리 연산자
        참(true)->1
        거짓(false)->0
        &&(and) : 둘다 참일 때
        \\(or) : 하나라도 참일 때
        !(not) : 참은 거짓으로, 거짓은 참으로
    4. 비교 연산자(>, >=, <, <=, ==, !=, ===, !==)
    === :값과 타입이 같아야 참을 반환.
    !== : 값과 타입이 같지 않아야 참을 반환.
    5. 단항 산술 연산자(++X, X++, --X, X--)
        ++x(--x) : 먼저 피연산자의 값을 1 증가(감소)시킨후 해당 연산 진행
        x++(x--) :  먼저 해당 연산을 수행 후 피연산자의 값을 1 증가(감소)
    6. nullish 병합 연산자(??)
    \\의 연산자와의 차이점 : \\은 0,빈 문자열 등을 포함한 falsy한 값을 방지하고, ??는 오직 null이나 undefined한 값을 방지한다.

        undefiend : 변수는 존재하나, 어떠한 값으로도 할당되지 않아 자료형이 정해지지(undefined) 않은 상태입니다.
        null : 변수는 존재하나, null 로 (값이) 할당된 상태. 즉 null은 자료형이 정해진(defined) 상태입니다.

# 문자열(String)
    형태 : 'string', "string", `string`, `string${변수명}`
    호출 : 변수명, 변수명{0}(index 번호로 호출)
    메서드 :
        1.str.length : 문자열의 길이
        2.str.slice : 인덱스 번호로 잘라내기
        3.str.replace : 문자열 수정

# Boolean(논리값)
    형태 : True, False

# undefine
    형태 : let a,console.log(a)
# null
    형태 : let a = null (null이란 값을 명시)

# Array(배열)
    호출: 변수명, 변수명[0], 변수명[0][0]
    메서드 : forEach
                ex) (x => console.log(x **2)) : 배열 순회
            map : forEach와 같이 배열 순회해서 각 원소들을 출력하는데 실행결과를 모은 새 배열을 리턴한다.
            filter : 배열을 순회하며 요소마다 조건 확인 후 조건을 만족하는 원소들로 구성된 새로운 배열을 리턴한다.(고유한 값일 때는 find로 사용한다.(ex. Id 같은 경우))
            fill : 스타트 인덱스부터 엔드 인덱스 전까지(엔드 인덱스는 미포함) value 값으로 채워주는 함수이다.

# Object (객체)
    호출 : 키(Key)와 값(Value)로 존재
    수정, 삭제 :
        수정(추가) 변수[키] = 값(null도 존재)
        삭제 : delete 변수["키"]는 추천하지 않음, 변수[키]=null로 표시해준다.

    메서드 :
        Object.keys : 키 값만 출력
        Object.values : 값만 출력
        Object.entries : 대상 객체를 각 [키,값] 배열로 담을 배열

# Set
    메서드 : add, delete, has, size
    중복을 허락하지 않는다. 합집합,교집합,차집합 등에 메서드가 있진 않지만. 구현하기 위해 set을 이용하는 경우가 많다.

    ex) let a = new Set([1, 2, 3])
        let b = new Set([3, 4, 5])
        const 합집합 = new Set([...a, ...b]);
        const 교집합 = new Set([...a].filter(x => b.has(x)));
        const 차집합1 = new Set([...a].filter(x => !b.has(x)));
        const 차집합2 = new Set([...b].filter(x => !a.has(x)));

# 조건문
    if : 만약이라는 가정하에 조건이 참이면 실행하고 거짓이면 실행하지 않는다.
    else if : 조건이 여러가지일 때 쓰고 if가 거짓이 되면 실행된다.
    else : 모든 조건이 불만족됐을 때 최종적으로 실행된다.
    switch : 여러개의 코드블록 중에서 하나를 선택해야 될때 사용한다.

# 반복문
    for : 가장 기본적인 반복문의 형태로, 내부에 변수를 선언하여 사용하며, 원하는 만큼 반복횟수를 지정하여 반복한다.
    for-in : 어떤 배열에 대핸 반복하는 것으로, 해당 인덱스에 직접 접근한다.
    for-of : 해당 인덱스가 아닌 요소에 직접 접근한다. 
    while : for문이 정해진 횟수만큼 반복한다면, while문은 조건식이 true일 경우에 계속해서 반복한다. 조건식이 false가 되면 반복 행위를 멈추고 while문을 종료한다.
    do-while : while문은 루프에 진입하기 전에 먼저 조건식부터 검사하지만 do-while문은 조건식의 결과와 상관없이 무조건 한번은 루프를 실행한다.
    break : for문, while문, do-while문을 종료한다.
    continue : for문에서 continue를 만나게 되면 증감식으로 바로 이동하게 하며, while문, do-while문은 조건식으로 이동하도록 한다.

# 함수
    선언 : 1. let 함수표현식 = function(){} (호이스팅x)
           2. function 함수선언식(){} (호이스팅o)
    
    매개변수(parameter) : x, y
    전달인자(argument) : 3,5

    콜백 함수 : 자바스크립트에서 함수는 객체이기 때문에 함수의 매개변수로 전달할 수 있는데, 다른 함수에 매개변수로 넘겨준 함수를 콜백 함수라고 부른다. 어떠한 이벤트가 발생하면 매개변수로 전달된 함수로 다시 호출되기 때문에 callback이라는 표현을 쓴다. 

    화살표 함수 : 함수를 만드는 조금 더 간결한 방법으로 기존 함수의 표현식에서 function 키워드를 삭제하고 매개변수의 괄호( )와 코드블록{ } 사이에 화살표(=>)만 넣어주면 바로 화살표 함수(Arrow function)가 된다.

    기명 함수와 익명 함수 : 기명 함수는 브라우저가 런타임 전에 선언 및 할당되는 함수이고, 익명 함수는 런타임에 할당되는 함수이다. 즉, 기명함수는 전체가 다 호이스팅 되므로 호출의 위치와 실행 위치 간에 연관관계가 없지만 익명함수는 호출의 위치와 구현의 위치 간에 순서가 알맞아야 하고, 한번만 사용하는 기능에 사용된다.

# class 
    객체 지향 프로그래밍에서 특정 객체를 생성하기 위해 변수와 메소드를 정의하는 일종의 틀로, 객체를 정의하기 위한 상태와 메서드로 구성된다. 즉, 클래스는 객체를 만들기 위해 쉽게 미리 틀을 만들어 놓은 것이다.

    생성 : new 키워드와 함께 클래스 이름을 호출하고, 생성자(constructor)에서 받을 인자를 넣어준다.

        생성자(constructor) : 인스턴스를 생성하고 초기화하기 위한 특수한 메서드이며, 이름을 변경할 수 없다.
        클래스 내에 최대 한개만 존재할 수 있으며, 생략도 가능하다.

        Method: 클래스 내에 정의하는 Method는 prototype에 저장된다. Method는 Function과 다름에 주의한다. Method는 특정 객체에 종속된 것으로 객체가 아닌 반면, Function은 객체로 취급된다.

    Function과의 차이 : Class는 new 키워드 없이 인스턴스 생성이 불가하다.

    상속 : 상속은 선언을 마친 클래스로부터 메소드와 속성을 물려받는 것을 의미한다. 상속 시에는 기존 클래스로부터 extends 키워드를 통해 상속을 받는다.

# 예외 처리
    예외(exception)란 프로그램이 실행 중에 발생하는 런타임 오류를 의미한다. 이러한 예외가 발생하지 않도록 미리 방지하는 것도 중요하지만, 발생된 예외를 처리하는 방법 또한 매우 중요하다.
    try : 에러가 났을 때 원상복구를 시도할 코드. 에러 발생시 코드의 실행 흐름이 catch 불록으로 옮겨간다.
    catch :에러에 대한 정보를 담고 있는 객체를 사용할 수 있다.
    finally : try 블록 안에서의 에러 발생 여부와 관계 없이 무조건 실행되어야 하는 코드.
    return, break, continue등으로 코드의 실행 흐름이 즉시 이동되더라도 무조건 실행된다.

        에러가 안 났을 때 : try - funally
        에러가 났을 때 : try - 에러발생 - catch - finally

# 전개 구문(Spread Syntax)
    전개 구문(spread operator)은 반복 가능한(iterable) 객체에 적용할 수 있는 문법이다. 배열이나 문자열 등을 아래처럼 풀어서 요소 하나 하나로 전개시킬 수 있다.

    문법 : 배열이나 객체 앞에 점 세개를 붙여준다.

    전개 연산자는 배열의 아무 곳에나 추가 할 수 있다는 장점이 있다.

    배열 리터럴의 전개 : 복사, 추가, 이어 붙이기 등 다양한 작업에서 연산자를 사용할 수 있다.

    const obj1 = { name: 'John', age: '20' };
    const obj2 = { name: 'Tom', age: '23' };

    const clonedObj1 = { ...obj1 };
    // Object { name: 'John', age: '20 }

    const mergedObj = { ...obj1, ...obj2 };
    // Object { name: 'John', age: '20', name: 'Tom', age: '23' }

    위에서 clonedObj1은 obj1의 프로퍼티만 복사받은 객체이다. 따라서 두 객체의 참조값 자체는 다르다.

# 정규 표현식

- `^` : 문자열의 시작
- `$` : 문자열의 종료. 옵션에 따라 문장의 끝 또는 문서의 끝에 매치된다.
- `.` : 임의의 한 문자
- `[]`: 문자 클래스. 문자 클래스 안에 들어가 있는 문자는 그 바깥에서 하나의 문자로 취급된다.
- `^` : 문자 클래스 내에서 ^는 not
- `-` : ex) a-z는 a에서 z까지의 문자
- `|` : or를 나타냄
- `?` : 앞 문자가 없거나 하나 있음
- `+` : 앞 문자가 하나 이상임
- `*` : 앞 문자가 0개 이상임
- `{n,m}` : 앞 문자가 `n`개 이상 `m`개 이하. `{0,1}` 은 `?`와 같은 의미다.
- `{n,}` : 앞 문자가 `n`개 이상. 위의 형태에서 `m`이 생략된 형태이다. `{0,}` 이면 `*`와 같고 `{1,}` 이면 `+`와 같은 의미이다.
- `{n}` : 앞 문자가 정확히 `n`개. `{n,n}` 과 같은 의미이다.
- `()` : 하나의 패턴구분자 안에 서브 패턴을 지정해서 사용할 경우 괄호로 묶어주는 방식을 사용한다.
- `\\s` : 공백문자
- `\\b` : 문자와 공백 사이를 의미한다.
- `\\d` : 숫자 [0-9]와 같다.
- `\\t` : 탭문자
- `\\w` : 단어 영문자+숫자+_(밑줄) [0-9a-zA-Z_]문자 이스케이프는 대문자로 적으면 반대를 의미한다.
[a-z] : a ~ z 사이의 문자를 찾음
[1-9] : 1 ~ 9 사이의 문자를 찾음
[abc] : a, b, c중 하나를 찾음
[^abc] : a, b, c를 제외한 문자를 찾음
.z : 아무 문자 하나를 . 기호로 찾으며 z로 끝남을 의미
a+ : a가 1개 이상을 의미함
a* : a가 0개 또는 그 이상을 의미함
s : 공백 문자를 찾음(스페이스, 탭 등), 대문자의 경우 아닌 문자를 찾음
d : 숫자를 찾음, 대문자의 경우 아닌 문자를 찾음
w : 알파벳 영문과 숫자와 언더바 _ 기호를 찾음, 대문자의 경우 아닌 문자를 찾음
t : 탭 공간을 찾음
g : 검색범위를 전역으로 확장
i : 대소문자를 구분하지 않음
gi : 검색 범위를 전역으로 확대하면서 대소문자를 구분하지 않음
m : 여러줄을 동시에 매칭함

# 리터럴
    약속된 기호를 사용해 값을 생성한다. 문자를 생성하기 위해서는 작은 따옴표,큰 따옴표,템플릿 리터럴 중 하나를 사용한 것처럼 배열을 생성할려면 대괄호를, 오브젝트를 생성하려면 중괄호를 사용해야 한다.

    2진수, 8진수, 16진수 리터럴
        let a = 0b1001 // a == 9
        let b = 0o1001 // b == 513
        let c = 0x1001 // c == 4097

# 구조 분해할당
    배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게하는 표현식이다.

    배열 분해하기 : 배열이 분해했다고 해서 분해 대상이 수정되거나 파괴되지 않는다.

    나머지 요소 가져오기 : 배열 앞쪽에 위치한 값 몇 개만 필요하고 그 이후 나머지 값들은 한데 모아서 저장 할 때, ...을 이용해서 나머지 요소를 가져온다.

    기본값: 할당하고자 하는 변수의 개수가 분해하고자 하는 배열의 길이보다 크면, 할당할 값이 없는 변수들은 undefined가 할당된다.

    객체 분해하기 : 할당 연산자 우측에는 분해하고자 하는 객체, 좌측에는 원하는 키를 넣는다.

    매개변수 분해하기 : 매개변수를 객체에 모아서 함수에 전달했을 때, 함수 내부에서 객체를 분해해서 변수에 할당하는 것이 쉬워진다. 다만 반드시 함수에 값이 전달된다는 가정이 존재하므로, 넣을 값이 없을 경우에는 빈 객체를 명시적으로 전달해야한다.

# 동기와 비동기
    동기(Synchronous: 동시에 일어나는) :
        동기는 말 그대로 동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속이다.

        바로 요청을 하면 시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 한다.

        순서에 맞춰 진행되는 장점이 있지만,  여러 가지 요청을 동시에 처리할 수 없다.

    비동기(Asynchronous: 동시에 일어나지 않는)
        비동기는 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을 거라는 약속이다.

        하나의 요청에 따른 응답을 즉시 처리하지 않아도, 그 대기 시간동안 또 다른 요청에 대해 처리 가능한 방식이다.

        여러 개의 요청을 동시에 처리할 수 있는 장점이 있지만 동기 방식보다 속도가 떨어질 수도 있다.
 
        콜백함수 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수 callback function이라고 한다. 콜백 함수는 고차 함수에 의해 호출되며, 이때 고차함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

        콜백지옥 :  콜백 지옥은 비동기 프로그래밍시 발생하는 문제로, 함수의 매개변수로 넘겨지는 콜백 함수가 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상을 말한다.

        비동기적 처리의 이유 : 모든 데이터의 수신을 완료한 다음 나머지 코드를 실행할 수 있으므로, 데이터를 받아오는 동안에 프로그램은 사실상 멈춰있는것과 다름없다. 언제 끝날지도 모르는 요청때문에 나머지 코드를 실행시키지 못하고 사용자를 기다리게 하는 아주 불친절한 프로그램이 되기 때문에 데이터를 수신해야할 때마다 기다려야 하는 사용자의 불편을 없애기 위해, 데이터의 수신과 기다려야하는 코드들을 비동기적으로 처리한다.

    블록 & 논블록

        블록 : 호출된 함수가 자신이 할 일을 모두 마칠 때까지 제어권을 계속 가지고서 호출한 함수에게 바로 return 하지 않는다.

        논블록 : 호출된 함수가 자신이 할 일을 마치지 않았더라도 바로 제어권을 바로 return하여 호출한 함수가 다른 일을 진행할 수 있도록 한다.

# Fetch
    Fetch는 비동기 네트워크 통신을 구현하기 위해 사용하는 Web API이다.
    자바스크립트를 이용하여 브라우저가 서버에게 비동기적으로 데이터를 요청하고, 응답 받은 데이터를 동적으로 페이지 렌더링 하는 방식을 Ajax(Asynchronous Javascript and XML)라고 하고 대표적인 Web API로는 XMLHttpRequest 객체, JQuery, fetch 등이 있다.

    - response.text()
    - response.json()
    - response.formData() - FormData 객체 반환
    - response.blob() - Blob(타입이 있는 바이너리 데이터) 형태 반환
    - Blob(Binary Large Object)은 이미지 등과 같은 멀티미디어 데이터를 다룰 때 사용하는 데이터 형식
    - [https://heropy.blog/2019/02/28/blob/](https://heropy.blog/2019/02/28/blob/) 블로그 글 추천
    - response.arrayBuffer() – ArrayBuffer(바이너리 데이터를 로우 레벨 형식으로 표현한 것) 형태 반환

# DOM

    문서 객체 모델(DOM, Document Object Model)은 XML이나 HTML 문서에 접근하기 위한 일종의 인터페이스이다. 이 객체 모델은 문서 내의 모든 요소를 정의하고, 각각의 요소에 접근하는 방법을 제공한다.


    / 해당하는 Id를 가진 요소에 접근하기
    document.getElementById()

    // 해당하는 모든 요소에 접근하기
    document.getElementsByTagName();

    // 해당하는 클래스를 가진 모든 요소에 접근하기
    document.getElementsByClassName();

    // css 선택자로 단일 요소에 접근하기
    document.querySelector("selector");

    // css 선택자로 여러 요소에 접근하기
    document.querySelectorAll("selector");

    // target 요소를 생성합니다.
    document.createElement(target);

    // target 텍스트를 생성합니다.
    document.createTextNode(target);

    // target 요소를 element의 자식으로 위치합니다.
    element.appendChild(target);

    // element의 target 자식 요소를 제거합니다.
    element.removeChild(target);  
 


    

    







    




